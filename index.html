<!DOCTYPE html>
<html lang="fr">

<head>
    <title>Game of life</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from './three.module.js';
    // import {OrbitControls} from './OrbitControls.js';

    Math.radians = (degrees) => degrees * Math.PI / 180;
    let camera, scene, renderer;
    let terrain, mesh, array, newArray;
    let group = new THREE.Group();
    let arrayGroup = new THREE.Group();
    let arrayGroupNew = new THREE.Group();
    let frequence = 0;
    let frequenceMax = 60;

    /**
     * Textures mat√©riel
     */
    const blackTextPath = './text/black-s.png';
    const whiteTextPath = './text/white-s.png';
    const greenTextPath = './text/green-s.png';

    const blackText = new THREE.TextureLoader().load(blackTextPath);
    const whiteText = new THREE.TextureLoader().load(whiteTextPath);
    const greenText = new THREE.TextureLoader().load(greenTextPath);

    const blackMat = new THREE.MeshBasicMaterial({map: blackText});
    const whiteMat = new THREE.MeshBasicMaterial({map: whiteText});
    const greenMat = new THREE.MeshBasicMaterial({map: greenText});

    /**
     * Dimensions
     */
    const terrainDim = {
        Width: 50,
        Height: 25
    };

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 100);
        camera.position.z = 0;
        camera.position.y = 30;
        camera.rotation.x -= Math.radians(90);
        var geometry;

        /**
         * Ajout du terrain
         */
         geometry = new THREE.PlaneGeometry(terrainDim.Width, terrainDim.Height);
        terrain = new THREE.Mesh(geometry, whiteMat);
        terrain.rotateX(Math.radians(-90));
        scene.add(terrain);

        /**
         * CubeLife
         */
         initArray();

        /**
        * Affichage
        */
        group.add(terrain);
        showArray();
        instanceToScene();

        /**
         * Options de rendu
         */
         renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize, false);
    }

    function instanceToScene(mesh) {
        if (mesh !== undefined) {
            group.add(mesh.clone());
        }
        scene.add(group);
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (++frequence % frequenceMax === 0) {
            isAlive();
            showArray();
        }
        renderer.render(scene, camera);
    }

    function showArray() {
        arrayGroupNew = new THREE.Group();
        let geometry = new THREE.BoxGeometry(0.9, 0.5, 0.9);
        let cube = new THREE.Mesh(geometry, greenMat);

        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                if (array[i][j] === 1) {
                    cube.position.set(j - Math.ceil(terrainDim.Width / 2) + 0.5,
                        -0.25,
                        i - Math.ceil(terrainDim.Height / 2) + 1);
                    arrayGroupNew.add(cube.clone());
                }
            }
        }
        scene.remove(arrayGroup);
        arrayGroup = arrayGroupNew;
        scene.add(arrayGroup);
    }

    function initArray() {
        array = [];
        newArray = [];
        for (let i = 0; i < terrainDim.Height; i++) {
            array[i] = [];
            newArray[i] = [];
            for (let j = 0; j < terrainDim.Width; j++) {
                array[i][j] = Math.floor(Math.random() * 11) % 2;
                newArray[i][j] = 0;
            }
        }
    }

    function isAlive() {
        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                let alive = 0;
                const neighbours = [
                    {
                        x: j - 1, y: i - 1,
                    },
                    {
                        x: j, y: i - 1,
                    },
                    {
                        x: j + 1, y: i - 1,
                    },
                    {
                        x: j + 1, y: i,
                    },
                    {
                        x: j + 1, y: i + 1,
                    },
                    {
                        x: j, y: i + 1,
                    },
                    {
                        x: j - 1, y: i + 1,
                    },
                    {
                        x: j - 1, y: i,
                    },
                ];
                neighbours.forEach(neighbour => {
                    if (neighbour.y >= 0 && neighbour.x >= 0 && neighbour.y < terrainDim.Height && neighbour.x < terrainDim.Width) {
                        if (array[neighbour.y][neighbour.x] === 1) {
                            alive++;
                        }
                    }
                });
                console.log('alive ' + alive);
                if ((array[i][j] === 1 && alive === 2) || alive === 3) {
                    newArray[i][j] = 1;
                } else {
                    newArray[i][j] = 0;
                }
            }
        }
        array = newArray;
    }

    </script>
</body>

</html>