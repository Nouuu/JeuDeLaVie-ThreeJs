<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Game of life</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from './three.module.js';
    // import {OrbitControls} from './OrbitControls.js';

    Math.radians = (degrees) => degrees * Math.PI / 180;
    let camera, scene, renderer;
    let terrain, mesh, array, newArray;
    let group = new THREE.Group();
    let arrayGroup = new THREE.Group();
    let arrayGroupNew = new THREE.Group();
    let frequence = 0;
    let frequenceMax = 3;

    /**
     * Textures mat√©riel
     */
    var blackTextPath = './text/black-s.png';
    var whiteTextPath = './text/white-s.png';
    var greenTextPath = './text/green-s.png';

    var blackText = new THREE.TextureLoader().load(blackTextPath);
    var whiteText = new THREE.TextureLoader().load(whiteTextPath);
    var greenText = new THREE.TextureLoader().load(greenTextPath);

    var blackMat = new THREE.MeshBasicMaterial({map: blackText});
    var whiteMat = new THREE.MeshBasicMaterial({map: whiteText});
    var greenMat = new THREE.MeshBasicMaterial({map: greenText});


    /**
     * Dimensions
     */
    const terrainDim = {
        Width: 100,
        Height: 50
    };


    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 100);
        camera.position.z = 0;
        camera.position.y = 40;
        camera.rotation.x -= Math.radians(90);
        var geometry;


        /**
         * Ajout du terrain
         */
        geometry = new THREE.PlaneGeometry(terrainDim.Width, terrainDim.Height);
        terrain = new THREE.Mesh(geometry, whiteMat);
        terrain.rotateX(Math.radians(-90));
        scene.add(terrain);


        /**
         * CubeLife
         */
        initArray();

        /**
         * Affichage
         */
        group.add(terrain);
        showArray();
        // setInterval(isAlive(), 3000);
        // scene.add(arrayGroup);
        instanceToScene();

        /**
         * Options de rendu
         */
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize, false);
    }

    function instanceToScene(mesh) {
        if (mesh !== undefined) {
            group.add(mesh.clone());
        }
        scene.add(group);
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (++frequence % frequenceMax === 0) {
            isAlive();
            showArray();
        }
        renderer.render(scene, camera);
    }

    function showArray() {
        arrayGroupNew = new THREE.Group();
        let geometry = new THREE.BoxGeometry(0.9, 0.5, 0.9);
        let cube = new THREE.Mesh(geometry, greenMat);

        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                if (array[i][j] === 1) {
                    cube.position.set(j - terrainDim.Width / 2 + .5,
                        -0.25,
                        i - terrainDim.Height / 2 + .5);
                    arrayGroupNew.add(cube.clone());
                }
            }
        }
        scene.remove(arrayGroup);
        arrayGroup = arrayGroupNew;
        scene.add(arrayGroup);
    }

    function initArray() {
        array = [];
        newArray = [];
        for (let i = 0; i < terrainDim.Height; i++) {
            array[i] = [];
            newArray[i] = [];
            for (let j = 0; j < terrainDim.Width; j++) {
                array[i][j] = Math.floor(Math.random() * 11) % 11;
                newArray[i][j] = 0;
            }
        }
    }

    // function tmpArray(terrainDim) {
    //     tmpArray = [];
    //     for (let i = 0; i < terrainDim.Height; i++) {
    //         tmpArray[i] = [];
    //         for (let j = 0; j < terrainDim.Width; j++) {
    //             tmpArray[i][j] = 0;
    //         }
    //     }
    // }
    //
    // /**
    //  * Useless
    //  * newArray = oldArray
    //  */
    // function changeArray(oldArray, newArray, terrainDim) {
    //     for (let i = 0; i < terrainDim.Height; i++) {
    //         for (let j = 0; j < terrainDim.Height; j++) {
    //             newArray[i][j] = oldArray[i][j];
    //         }
    //     }
    // }

    /**
     * A optimiser, bcp trop de if
     */
    function isAlive() {
        let counter = 0;
        let alive = 0;
        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                alive = 0;
                if (array[i][j] === 1) {
                    counter++;
                }
                let a;
                let b;
                a = i - 1;
                b = j - 1;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i - 1;
                b = j;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i - 1;
                b = j + 1;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i;
                b = j - 1;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i;
                b = j + 1;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i + 1;
                b = j - 1;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i + 1;
                b = j;
                alive = nearAlive(a, b, terrainDim, alive);

                a = i + 1;
                b = j + 1;
                alive = nearAlive(a, b, terrainDim, alive);

                if ((array[i][j] === 1 && alive === 2) || alive === 3) {
                    newArray[i][j] = 1;
                } else {
                    newArray[i][j] = 0;
                }
                console.log("Array[".concat(i, "][", j, "] = ", array[i][j]));
                console.log("Devient");
                console.log("Array[".concat(i, "][", j, "] = ", newArray[i][j]));
                console.log("---")
            }
        }
        array = newArray;
    }

    function nearAlive(i, j, terrainDim, alive) {
        if (i >= 0 && j >= 0 && i < terrainDim.Height && j < terrainDim.Width) {
            if (array[i][j] === 1) {
                alive = alive + 1;
            }
        }
        return alive;
    }

</script>
</body>
</html>
