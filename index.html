<!DOCTYPE html>
<html lang="fr">

<head>
    <title>Game of life</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from './three.module.js';
    import {GUI} from './dat.gui.module.js';

    var settings;
    // import {OrbitControls} from './OrbitControls.js';

    Math.radians = (degrees) => degrees * Math.PI / 180;
    let camera, scene, renderer;
    let terrain, mesh, array, newArray;
    let group = new THREE.Group();
    let arrayGroup = new THREE.Group();
    let arrayGroupNew = new THREE.Group();
    let frequence = 0;
    let frequenceMax = 3;

    /**
     * Textures mat√©riel
     */
    const blackTextPath = './text/black-s.png';
    const whiteTextPath = './text/white-s.png';
    const greenTextPath = './text/green-s.png';

    const blackText = new THREE.TextureLoader().load(blackTextPath);
    const whiteText = new THREE.TextureLoader().load(whiteTextPath);
    const greenText = new THREE.TextureLoader().load(greenTextPath);

    const blackMat = new THREE.MeshBasicMaterial({map: blackText});
    const whiteMat = new THREE.MeshBasicMaterial({map: whiteText});
    const greenMat = new THREE.MeshBasicMaterial({map: greenText});

    /**
     * Dimensions
     */
    const terrainDim = {
        Width: 100,
        Height: 50
    };

    /**
     * GUI
     */

    var gui = new GUI({
        height: 3 * 32 - 1
    });

    gui.add(terrainDim, 'Width').min(5).max(100).step(1);
    gui.add(terrainDim, 'Height').min(5).max(50).step(1).onFinishChange(function () {
        initArray();
        scene.remove(terrain);
        let geometry = new THREE.PlaneGeometry(terrainDim.Width, terrainDim.Height);
        terrain = new THREE.Mesh(geometry, whiteMat);
        terrain.rotateX(Math.radians(-90));
        scene.add(terrain);
    });

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 100);
        camera.position.z = 0;
        camera.position.y = 40;
        camera.rotation.x -= Math.radians(90);
        var geometry;

        // createPanel();

        /**
         * Ajout du terrain
         */
        geometry = new THREE.PlaneGeometry(terrainDim.Width, terrainDim.Height);
        terrain = new THREE.Mesh(geometry, whiteMat);
        terrain.rotateX(Math.radians(-90));
        scene.add(terrain);

        /**
         * CubeLife
         */
        initArray();

        /**
         * Affichage
         */
        showArray();

        /**
         * Options de rendu
         */
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize, false);
    }

    function instanceToScene(mesh) {
        if (mesh !== undefined) {
            group.add(mesh.clone());
        }
        scene.add(group);
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (++frequence % frequenceMax === 0) {
            isAlive();
            showArray();
        }
        renderer.render(scene, camera);
    }

    function showArray() {
        arrayGroupNew = new THREE.Group();
        let geometry = new THREE.BoxGeometry(0.9, 0.5, 0.9);
        let cube = new THREE.Mesh(geometry, greenMat);

        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                if (array[i][j] === 1) {
                    cube.position.set(j - terrainDim.Width / 2 + .5,
                        -0.25,
                        i - terrainDim.Height / 2 + .5);
                    arrayGroupNew.add(cube.clone());
                }
            }
        }
        scene.remove(arrayGroup);
        arrayGroup = arrayGroupNew;
        scene.add(arrayGroup);
    }

    function initArray() {
        array = [];
        newArray = [];
        for (let i = 0; i < terrainDim.Height; i++) {
            array[i] = [];
            newArray[i] = [];
            for (let j = 0; j < terrainDim.Width; j++) {
                array[i][j] = Math.floor(Math.random() * 11) % 10;
                newArray[i][j] = 0;
            }
        }
    }

    function isAlive() {
        for (let i = 0; i < terrainDim.Height; i++) {
            for (let j = 0; j < terrainDim.Width; j++) {
                let alive = 0;
                const neighbours = [
                    {
                        x: j - 1, y: i - 1,
                    },
                    {
                        x: j, y: i - 1,
                    },
                    {
                        x: j + 1, y: i - 1,
                    },
                    {
                        x: j + 1, y: i,
                    },
                    {
                        x: j + 1, y: i + 1,
                    },
                    {
                        x: j, y: i + 1,
                    },
                    {
                        x: j - 1, y: i + 1,
                    },
                    {
                        x: j - 1, y: i,
                    },
                ];
                neighbours.forEach(neighbour => {
                    if (neighbour.y >= 0 && neighbour.x >= 0 && neighbour.y < terrainDim.Height && neighbour.x < terrainDim.Width) {
                        if (array[neighbour.y][neighbour.x] === 1) {
                            alive++;
                        }
                    }
                });
                console.log('alive ' + alive);
                if ((array[i][j] === 1 && alive === 2) || alive === 3) {
                    newArray[i][j] = 1;
                } else {
                    newArray[i][j] = 0;
                }
            }
        }
        array = newArray;
    }

    function createPanel() {
        var panel = new GUI({width: 200, height: 5 * 302 - 1});
        var folder1 = panel.addFolder('Light');
        var folder2 = panel.addFolder('Size');
        var folder3 = panel.addFolder('Speed');

        settings = {
            'terrainWidth': 5,
            'terrainHeight': 5/*,
            'speed': 5,
            'pause/continue': pause,
            'from walk to idle': function () {
                prepareCrossFade( walkAction, idleAction, 1.0 );
            }*/
        };

        folder2.add(settings, 'terrainWidth', 0, 100, 1);
        folder2.add(settings, 'terrainHeight', 0, 50, 1);
        /*folder1.add( settings, 'show model' ).onChange( showModel );
        folder3.add( settings, 'pause/continue' );
        folder3.add( settings, 'set custom duration', 0, 10, 0.01 );
        folder3.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {
            setWeight( runAction, weight );
        } );
        folder3.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );*/

        folder1.open();
        folder2.open();
        folder3.open();
    }


</script>
</body>

</html>